<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>KOMPASS EOD COVER SHEET</title>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib/dist/pdf-lib.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #374151;
            min-height: 100vh;
            padding: 20px;
            color: #f9fafb;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
            background: #111827;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            cursor: pointer;
        }

        .header-logo {
            max-width: 500px;
            width: 80%;
            margin-bottom: 15px;
        }

        .header h1 {
            color: #88c4ed;
            font-size: 1.8em;
            margin-bottom: 5px;
        }

        .header p {
            color: #d1d5db;
            font-size: 0.9em;
            margin: 2px 0;
        }

        .section {
            background: #020617;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 2px solid #0d4f8b;
        }

        .section-title {
            color: #88c4ed;
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid #0d4f8b;
        }

        .field-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .field {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .field label {
            color: #88c4ed;
            font-weight: 600;
            font-size: 0.9em;
        }

        .field input[type="text"],
        .field input[type="date"],
        .field input[type="email"],
        .field textarea {
            padding: 10px;
            border: 1px solid #4b5563;
            border-radius: 5px;
            background: #374151;
            color: #f9fafb;
            font-size: 1em;
            font-family: inherit;
        }

        .field textarea {
            min-height: 80px;
            resize: vertical;
        }

        .checkbox-group {
            display: flex;
            gap: 15px;
            align-items: center;
            margin-top: 8px;
        }

        .checkbox-option {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .checkbox-option input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: #0d4f8b;
            cursor: pointer;
        }

        .checkbox-option label {
            cursor: pointer;
            color: #f9fafb;
        }

        /* Email recipient management styles */
        .email-input-group {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .email-input-group input {
            flex: 1;
        }

        .add-recipient-btn {
            white-space: nowrap;
            padding: 10px 15px;
        }

        .recipient-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .recipient-tag {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            background: #4b5563;
            color: #f9fafb;
            padding: 6px 10px;
            border-radius: 20px;
            font-size: 0.9em;
        }

        .recipient-tag .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            padding: 0;
        }

        .recipient-tag .remove-btn:hover {
            background: #dc2626;
        }

        .photo-section {
            margin-top: 15px;
        }

        .photo-upload {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .photo-button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .photo-button {
            padding: 12px 20px;
            background: #0d4f8b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex: 1;
            min-width: 150px;
        }

        .photo-button:hover {
            background: #1e66ab;
            transform: translateY(-2px);
        }

        .photo-preview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .photo-item {
            position: relative;
            border: 2px solid #0d4f8b;
            border-radius: 8px;
            overflow: hidden;
            aspect-ratio: 4/3;
            cursor: pointer;
        }

        .photo-item img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .photo-remove {
            position: absolute;
            top: 5px;
            right: 5px;
            background: #dc2626;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .photo-edit {
            position: absolute;
            top: 5px;
            left: 5px;
            background: #0d4f8b;
            color: white;
            border: none;
            border-radius: 50%;
            width: 25px;
            height: 25px;
            cursor: pointer;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2;
        }

        .signature-section {
            margin-top: 20px;
        }

        .signature-preview {
            border: 2px solid #0d4f8b;
            border-radius: 8px;
            background: white;
            min-height: 150px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #111827;
            margin-top: 10px;
        }

        .signature-preview img {
            max-width: 100%;
            max-height: 150px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            padding: 14px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            flex: 1;
            min-width: 150px;
        }

        .btn-primary {
            background: #0d4f8b;
            color: white;
        }

        .btn-primary:hover {
            background: #1e66ab;
            transform: translateY(-2px);
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f 0%, #a8e063 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(86, 171, 47, 0.4);
        }

        .btn-secondary {
            background: #4b5563;
            color: #f9fafb;
        }

        .btn-secondary:hover {
            background: #5a6573;
        }

        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal-dialog {
            background: #374151;
            padding: 24px;
            border-radius: 12px;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            color: #f9fafb;
        }

        .modal-dialog h2 {
            color: #88c4ed;
            margin-bottom: 15px;
        }

        .loading-overlay {
            position: fixed;
            inset: 0;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(17, 24, 39, 0.8);
            z-index: 10000;
            font-size: 1.5em;
            font-weight: bold;
            color: #88c4ed;
            backdrop-filter: blur(5px);
        }

        .loading-overlay.show {
            display: flex;
        }

        input[type="file"] {
            display: none;
        }

        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }

            .field-group {
                grid-template-columns: 1fr;
            }

            .button-group {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: #4b5563;
            border-radius: 8px;
        }

        .toggle-switch-label {
            color: #f9fafb;
            font-weight: 600;
            margin-left: 12px;
            cursor: pointer;
        }

        .toggle-switch-wrapper {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 28px;
            cursor: pointer;
        }

        .toggle-switch-wrapper input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #374151;
            border-radius: 28px;
            transition: .3s;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            border-radius: 50%;
            transition: .3s;
        }

        input:checked + .toggle-slider {
            background-color: #0d4f8b;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(22px);
        }

        .signature-fullscreen-overlay {
            position: fixed;
            inset: 0;
            background: #111827;
            display: none;
            z-index: 10002;
            flex-direction: column;
        }

        .signature-fullscreen-overlay.show {
            display: flex;
        }

        .sig-toolbar {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px;
            background: #0d4f8b;
            color: #fff;
        }

        #sigFsCanvas {
            flex: 1;
            background: #fff;
            touch-action: none;
            display: block;
            width: 100%;
            height: 100%;
        }

        .camera-fullscreen-overlay {
            position: fixed;
            inset: 0;
            background: #000;
            display: none;
            z-index: 10003;
            flex-direction: column;
        }

        .camera-fullscreen-overlay.show {
            display: flex;
        }

        .camera-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px;
            background: rgba(13, 79, 139, 0.9);
            color: #fff;
            gap: 8px;
        }

        .camera-toolbar-left {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .camera-toolbar-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        #cameraVideo {
            width: 100%;
            height: 0;
            flex-grow: 1;
            object-fit: cover;
            background: #000;
        }

        .camera-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            background: rgba(13, 79, 139, 0.9);
            gap: 15px;
            flex-shrink: 0;
            z-index: 10;
        }

        .capture-button {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: #fff;
            border: 5px solid #0d4f8b;
            cursor: pointer;
            transition: transform 0.1s;
            position: relative;
        }

        .capture-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: #0d4f8b;
        }

        .capture-button:active {
            transform: scale(0.95);
        }

        .flash-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            cursor: pointer;
        }

        .flash-toggle.active {
            background: rgba(255, 255, 255, 0.4);
        }

        .photo-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
        }

        canvas {
            display: none;
        }

        /* Image Editor Overlay Styles */
        .image-editor-overlay {
            position: fixed;
            inset: 0;
            background: #111827;
            display: none;
            z-index: 10004;
            flex-direction: column;
        }

        .image-editor-overlay.show {
            display: flex;
        }

        .editor-toolbar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 12px;
            background: #0d4f8b;
            color: #fff;
            gap: 8px;
            flex-shrink: 0;
        }

        .editor-toolbar-left {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-toolbar-right {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .editor-canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
            background: #1f2937;
        }

        #editorCanvas {
            display: block !important;
            max-width: 100%;
            max-height: 100%;
            touch-action: none;
        }

        .crop-overlay {
            position: absolute;
            pointer-events: none;
            display: none;
        }

        .crop-overlay.active {
            display: block;
        }

        .crop-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .crop-shade-polygon {
            fill: rgba(0, 0, 0, 0.6);
            fill-rule: evenodd;
        }

        .crop-polygon-outline {
            fill: none;
            stroke: #88c4ed;
            stroke-width: 2;
            stroke-dasharray: 6, 4;
        }

        .crop-polygon-line {
            stroke: #88c4ed;
            stroke-width: 2;
            pointer-events: auto;
            cursor: crosshair;
        }

        .crop-handle {
            position: absolute;
            width: 24px;
            height: 24px;
            background: #0d4f8b;
            border: 3px solid #88c4ed;
            border-radius: 50%;
            pointer-events: auto;
            cursor: move;
            transform: translate(-50%, -50%);
            z-index: 10;
            touch-action: none;
        }

        .crop-handle:hover {
            background: #1a6fc4;
            transform: translate(-50%, -50%) scale(1.15);
        }

        .crop-handle:active {
            background: #2a8fe4;
            transform: translate(-50%, -50%) scale(1.1);
        }

        .crop-handle-label {
            position: absolute;
            color: #fff;
            font-size: 10px;
            font-weight: bold;
            text-align: center;
            width: 100%;
            line-height: 18px;
            pointer-events: none;
        }

        .editor-controls {
            display: flex;
            flex-direction: column;
            padding: 12px;
            background: rgba(13, 79, 139, 0.9);
            gap: 12px;
            flex-shrink: 0;
        }

        .editor-control-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .editor-control-group {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 12px;
            border-radius: 8px;
        }

        .editor-control-label {
            color: #fff;
            font-size: 0.9em;
            font-weight: 600;
            white-space: nowrap;
        }

        .editor-slider {
            width: 120px;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: #374151;
            border-radius: 3px;
            outline: none;
        }

        .editor-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #88c4ed;
            border-radius: 50%;
            cursor: pointer;
        }

        .editor-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #88c4ed;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }

        .editor-btn {
            padding: 8px 14px;
            border: none;
            border-radius: 6px;
            font-size: 0.9em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s;
            background: #4b5563;
            color: #fff;
        }

        .editor-btn:hover {
            background: #5a6573;
        }

        .editor-btn.active {
            background: #0d4f8b;
        }

        .editor-btn-icon {
            width: 36px;
            height: 36px;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2em;
        }

        .slider-value {
            color: #88c4ed;
            font-size: 0.85em;
            min-width: 35px;
            text-align: center;
        }

        @media (max-width: 480px) {
            .editor-slider {
                width: 80px;
            }
            .editor-control-group {
                padding: 6px 10px;
            }
            .editor-btn {
                padding: 6px 10px;
                font-size: 0.85em;
            }
        }

        /* Quick View Modal Styles */
        .quick-view-content {
            font-size: 0.95em;
            line-height: 1.6;
        }

        .quick-view-content .qv-row {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px solid #4b5563;
        }

        .quick-view-content .qv-row:last-child {
            border-bottom: none;
        }

        .quick-view-content .qv-label {
            color: #88c4ed;
            font-weight: 600;
        }

        .quick-view-content .qv-value {
            color: #f9fafb;
            text-align: right;
            max-width: 60%;
        }

        .quick-view-content .qv-section {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 2px solid #0d4f8b;
        }

        .quick-view-content .qv-section-title {
            color: #88c4ed;
            font-weight: bold;
            margin-bottom: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" onclick="openQuickView()">
            <img src="rologo.png" alt="Retail Odyssey Logo" class="header-logo" onerror="this.style.display='none'">
            <h1>KOMPASS</h1>
            <p>END OF DAY COVER SHEET</p>
            <p>GENERATOR</p>
        </div>

        <!-- Basic Info -->
        <div class="section">
            <div class="section-title">Store Information</div>
            <div class="field-group">
                <div class="field">
                    <label>Store #:</label>
                    <input type="text" id="storeNumber" list="storeList" placeholder="Select or enter store #">
                    <datalist id="storeList">
                        <option value="5">
                        <option value="11">
                        <option value="13">
                        <option value="17">
                        <option value="18">
                        <option value="19">
                        <option value="21">
                        <option value="23">
                        <option value="24">
                        <option value="25">
                        <option value="28">
                        <option value="30">
                        <option value="31">
                        <option value="35">
                        <option value="40">
                        <option value="41">
                        <option value="49">
                        <option value="50">
                        <option value="53">
                        <option value="60">
                        <option value="63">
                        <option value="70">
                        <option value="71">
                        <option value="75">
                        <option value="90">
                        <option value="93">
                        <option value="111">
                        <option value="122">
                        <option value="125">
                        <option value="126">
                        <option value="127">
                        <option value="135">
                        <option value="140">
                        <option value="143">
                        <option value="150">
                        <option value="153">
                        <option value="156">
                        <option value="158">
                        <option value="163">
                        <option value="165">
                        <option value="171">
                        <option value="180">
                        <option value="185">
                        <option value="186">
                        <option value="195">
                        <option value="196">
                        <option value="198">
                        <option value="208">
                        <option value="209">
                        <option value="210">
                        <option value="214">
                        <option value="215">
                        <option value="218">
                        <option value="220">
                        <option value="224">
                        <option value="225">
                        <option value="226">
                        <option value="227">
                        <option value="236">
                        <option value="240">
                        <option value="242">
                        <option value="253">
                        <option value="255">
                        <option value="260">
                        <option value="265">
                        <option value="281">
                        <option value="285">
                        <option value="286">
                        <option value="325">
                        <option value="328">
                        <option value="351">
                        <option value="355">
                        <option value="360">
                        <option value="372">
                        <option value="375">
                        <option value="377">
                        <option value="383">
                        <option value="390">
                        <option value="391">
                        <option value="393">
                        <option value="417">
                        <option value="424">
                        <option value="439">
                        <option value="449">
                        <option value="457">
                        <option value="458">
                        <option value="459">
                        <option value="460">
                        <option value="462">
                        <option value="464">
                        <option value="482">
                        <option value="485">
                        <option value="486">
                        <option value="516">
                        <option value="600">
                        <option value="603">
                        <option value="604">
                        <option value="605">
                        <option value="608">
                        <option value="613">
                        <option value="614">
                        <option value="615">
                        <option value="649">
                        <option value="650">
                        <option value="651">
                        <option value="652">
                        <option value="653">
                        <option value="654">
                        <option value="655">
                        <option value="656">
                        <option value="657">
                        <option value="658">
                        <option value="659">
                        <option value="660">
                        <option value="661">
                        <option value="662">
                        <option value="663">
                        <option value="665">
                        <option value="667">
                        <option value="668">
                        <option value="681">
                        <option value="682">
                        <option value="683">
                        <option value="685">
                        <option value="688">
                        <option value="691">
                        <option value="694">
                    </datalist>
                </div>
                <div class="field">
                    <label>Date:</label>
                    <input type="date" id="workDate">
                </div>
                <div class="field">
                    <label>Lead Name:</label>
                    <input type="text" id="leadName" placeholder="Your name">
                </div>
            </div>
        </div>

        <!-- Photos Section -->
        <div class="section">
            <div class="section-title">Photos</div>

            <div class="photo-section">
                <label class="field label">Kompass Cart - Before:</label>
                <div class="checkbox-group" style="margin-top: 4px;">
                    <div class="checkbox-option">
                        <input type="checkbox" id="beforeComplete">
                        <label for="beforeComplete">Kompass cart before picture taken.</label>
                    </div>
                </div>
                <div class="photo-button-group">
                    <button class="photo-button" onclick="openPhotoCamera('before')">
                        Take Photo
                    </button>
                    <button class="photo-button" onclick="document.getElementById('photoBefore').click()">
                        Upload Image
                    </button>
                </div>
                <input type="file" id="photoBefore" accept="image/*,.heic,.heif" onchange="handlePhoto(this, 'before')">
                <div id="previewBefore" class="photo-preview"></div>
            </div>

            <div class="photo-section">
                <label class="field label">Kompass Cart - After:</label>
                <div class="checkbox-group" style="margin-top: 4px;">
                    <div class="checkbox-option">
                        <input type="checkbox" id="afterComplete">
                        <label for="afterComplete">Kompass cart after picture taken.</label>
                    </div>
                </div>
                <div class="photo-button-group">
                    <button class="photo-button" onclick="openPhotoCamera('after')">
                        Take Photo
                    </button>
                    <button class="photo-button" onclick="document.getElementById('photoAfter').click()">
                        Upload Image
                    </button>
                </div>
                <input type="file" id="photoAfter" accept="image/*,.heic,.heif" onchange="handlePhoto(this, 'after')">
                <div id="previewAfter" class="photo-preview"></div>
            </div>

            <div class="photo-section">
                <label class="field label">Sign-Off Sheets:</label>
                <div class="checkbox-group" style="margin-top: 4px;">
                    <div class="checkbox-option">
                        <input type="checkbox" id="signoffComplete">
                        <label for="signoffComplete">All sign-off sheets have been photographed.</label>
                    </div>
                </div>
                <div class="photo-button-group">
                    <button class="photo-button" onclick="openSignoffCamera()">
                        Take Photos
                    </button>
                    <button class="photo-button" onclick="document.getElementById('photoSignoff').click()">
                        Upload Images
                    </button>
                </div>
                <input type="file" id="photoSignoff" accept="image/*,.heic,.heif" multiple onchange="handlePhoto(this, 'signoff')">
                <div id="previewSignoff" class="photo-preview"></div>
            </div>

        </div>

        <!-- EOD Fields -->
        <div class="section">
            <div class="section-title">EOD Cover Sheet</div>

            <div class="field">
                <label>Manager checked in with:</label>
                <input type="text" id="checkInManager" placeholder="Manager name">
            </div>

            <div class="field" style="margin-top: 15px;">
                <label>Did you call the KOMPASS Hotline?</label>
                <div class="checkbox-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="hotlineYes" name="hotline" value="Yes" onchange="toggleHotline(this)">
                        <label for="hotlineYes">Yes</label>
                    </div>
                    <div class="checkbox-option">
                        <input type="checkbox" id="hotlineNo" name="hotline" value="No" onchange="toggleHotline(this)">
                        <label for="hotlineNo">No</label>
                    </div>
                </div>
            </div>

            <div id="hotlineDetails" style="display: none; margin-top: 15px;">
                <div class="field">
                    <label>Commodities involved:</label>
                    <input type="text" id="commodities" placeholder="Enter commodities">
                </div>
                <div class="field" style="margin-top: 15px;">
                    <label>What is the issue?</label>
                    <textarea id="issue" placeholder="Describe the issue"></textarea>
                </div>
                <div class="field" style="margin-top: 15px;">
                    <label>Issue resolved?</label>
                    <div class="checkbox-group">
                        <div class="checkbox-option">
                            <input type="checkbox" id="resolvedYes" name="resolved" value="Yes" onchange="toggleResolved(this)">
                            <label for="resolvedYes">Yes</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="resolvedNo" name="resolved" value="No" onchange="toggleResolved(this)">
                            <label for="resolvedNo">No</label>
                        </div>
                        <div class="checkbox-option">
                            <input type="checkbox" id="resolvedNA" name="resolved" value="NA" onchange="toggleResolved(this)">
                            <label for="resolvedNA">N/A</label>
                        </div>
                    </div>
                </div>
                <div id="tempSolutionField" style="display: none; margin-top: 15px;">
                    <div class="field">
                        <label>Temporary solution:</label>
                        <textarea id="tempSolution" placeholder="Describe temporary solution"></textarea>
                    </div>
                </div>
            </div>

            <div class="field" style="margin-top: 15px;">
                <label>Manager checked out with:</label>
                <input type="text" id="checkOutManager" placeholder="Manager name">
            </div>

            <div class="field" style="margin-top: 15px;">
                <label>All sets signed out in PROD?</label>
                <div class="checkbox-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="prodYes" name="prod" value="Yes" onchange="toggleRadio('prod', this)">
                        <label for="prodYes">Yes</label>
                    </div>
                    <div class="checkbox-option">
                        <input type="checkbox" id="prodNo" name="prod" value="No" onchange="toggleRadio('prod', this)">
                        <label for="prodNo">No</label>
                    </div>
                </div>
            </div>

            <div class="field" style="margin-top: 15px;">
                <label>All sets signed out in SI?</label>
                <div class="checkbox-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="siYes" name="si" value="Yes" onchange="toggleRadio('si', this)">
                        <label for="siYes">Yes</label>
                    </div>
                    <div class="checkbox-option">
                        <input type="checkbox" id="siNo" name="si" value="No" onchange="toggleRadio('si', this)">
                        <label for="siNo">No</label>
                    </div>
                </div>
            </div>

            <div class="field" style="margin-top: 15px;">
                <label>Notes:</label>
                <textarea id="notes" placeholder="Any additional notes or observations"></textarea>
            </div>
        </div>

        <!-- Signature -->
        <div class="section signature-section">
            <div class="section-title">Signature</div>
            <div id="signaturePreview" class="signature-preview">Tap "Sign" to add signature</div>
            <button class="photo-button" onclick="openSignature()" style="margin-top: 10px;">Sign</button>
            <canvas id="signaturePad" style="display:none;"></canvas>
        </div>

        <!-- Email To Field -->
        <div class="section">
            <div class="section-title">Email Settings</div>
            <div class="field">
                <label>Add Recipient:</label>
                <div class="email-input-group">
                    <input type="email" id="emailInput" placeholder="recipient@example.com">
                    <button type="button" class="btn btn-primary add-recipient-btn" onclick="addEmailRecipient()">Add Recipient</button>
                </div>
            </div>
            <div class="field" id="recipientListContainer" style="margin-top: 10px; display: none;">
                <label>Recipients:</label>
                <div id="recipientList" class="recipient-list"></div>
            </div>
            <div class="field" style="margin-top: 10px;">
                <div class="checkbox-group">
                    <div class="checkbox-option">
                        <input type="checkbox" id="addRetailOdysseyTeam" onchange="autoSave()">
                        <label for="addRetailOdysseyTeam">Add Retail Odyssey Team to EOD</label>
                    </div>
                </div>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="button-group">
            <div class="toggle-switch">
                <label class="toggle-switch-wrapper">
                    <input type="checkbox" id="notesOnlyToggle">
                    <span class="toggle-slider"></span>
                </label>
                <label class="toggle-switch-label" for="notesOnlyToggle">Notes Only</label>
            </div>
            <button class="btn btn-success" onclick="generateEmail()">Generate Email</button>
            <button class="btn btn-secondary" onclick="testSetup()">Test Setup</button>
            <button class="btn btn-secondary" onclick="resetForm()">Reset</button>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <span>Processing...</span>
    </div>

    <!-- Modal -->
    <div id="modal" class="modal-overlay">
        <div class="modal-dialog">
            <h2 id="modalTitle">Title</h2>
            <div id="modalMessage">Message</div>
            <div class="button-group">
                <button class="btn btn-secondary" id="modalCancel">Cancel</button>
                <button class="btn btn-primary" id="modalConfirm">OK</button>
            </div>
        </div>
    </div>

    <!-- Email Options Modal -->
    <div id="emailOptionsModal" class="modal-overlay">
        <div class="modal-dialog" style="max-width: 400px;">
            <h2>PDF Generated Successfully</h2>
            <div id="emailOptionsMessage" style="margin-bottom: 15px; font-size: 13px;"></div>
            <div style="display: flex; flex-direction: column; gap: 10px;">
                <button class="btn btn-primary" id="emailOpenApp" style="width: 100%;">
                    Open Email App
                </button>
                <button class="btn btn-secondary" id="emailOpenOutlook" style="width: 100%;">
                    Open in Outlook.com
                </button>
                <button class="btn btn-secondary" id="emailDownloadEml" style="width: 100%;">
                    Download Email File (.eml)
                </button>
                <button class="btn btn-secondary" id="emailCopyAll" style="width: 100%;">
                    Copy Email Details
                </button>
                <button class="btn btn-secondary" id="emailShare" style="width: 100%; display: none;">
                    Share via Device
                </button>
                <button class="btn btn-secondary" id="emailOptionsClose" style="width: 100%; margin-top: 5px;">
                    Close
                </button>
            </div>
            <div id="copySuccessMsg" style="display: none; margin-top: 10px; padding: 8px; background: #1a5c2a; border-radius: 4px; font-size: 12px; text-align: center;">
                Copied to clipboard!
            </div>
        </div>
    </div>

    <!-- Signature Fullscreen Overlay -->
    <div id="signatureFullOverlay" class="signature-fullscreen-overlay">
        <div class="sig-toolbar">
            <button class="btn btn-secondary" id="sigClose">Close</button>
            <div style="margin-left:auto; display:flex; gap:8px;">
                <button class="btn btn-secondary" id="sigLoadPhoto">Load Photo</button>
                <button class="btn btn-secondary" id="sigClear">Clear</button>
                <button class="btn btn-primary" id="sigAccept">Accept</button>
            </div>
        </div>
        <canvas id="sigFsCanvas"></canvas>
        <input type="file" id="signaturePhotoInput" accept="image/*,.heic,.heif" style="display:none;">
    </div>

    <!-- Camera Fullscreen Overlay for Sign-off Sheets -->
    <div id="cameraFullOverlay" class="camera-fullscreen-overlay">
        <div class="camera-toolbar">
            <div class="camera-toolbar-left">
                <button class="btn btn-secondary" id="cameraClose">Done</button>
                <div class="photo-count" id="photoCount">0 photos</div>
            </div>
            <div class="camera-toolbar-right">
                <div class="flash-toggle" id="flashToggle">
                    <span>Flash</span>
                    <span id="flashStatus">Off</span>
                </div>
            </div>
        </div>
        <video id="cameraVideo" autoplay playsinline></video>
        <div class="camera-controls">
            <button class="capture-button" id="captureButton"></button>
        </div>
        <canvas id="captureCanvas"></canvas>
    </div>

    <!-- Image Editor Overlay for Sign-off Sheets -->
    <div id="imageEditorOverlay" class="image-editor-overlay">
        <div class="editor-toolbar">
            <div class="editor-toolbar-left">
                <button class="btn btn-secondary" id="editorCancel">Cancel</button>
            </div>
            <div class="editor-toolbar-right">
                <button class="btn btn-secondary" id="editorReset">Reset</button>
                <button class="btn btn-primary" id="editorSave">Save</button>
            </div>
        </div>
        <div class="editor-canvas-container" id="editorCanvasContainer">
            <canvas id="editorCanvas"></canvas>
            <div class="crop-overlay" id="cropOverlay">
                <svg class="crop-svg" id="cropSvg">
                    <defs>
                        <mask id="cropMask">
                            <rect x="0" y="0" width="100%" height="100%" fill="white"/>
                            <polygon id="cropMaskPolygon" fill="black"/>
                        </mask>
                    </defs>
                    <rect class="crop-shade-polygon" x="0" y="0" width="100%" height="100%" mask="url(#cropMask)"/>
                    <polygon id="cropPolygonOutline" class="crop-polygon-outline"/>
                </svg>
                <div id="cropHandlesContainer"></div>
            </div>
        </div>
        <div class="editor-controls">
            <div class="editor-control-row">
                <div class="editor-control-group">
                    <span class="editor-control-label">Brightness</span>
                    <input type="range" id="brightnessSlider" class="editor-slider" min="-100" max="100" value="0">
                    <span class="slider-value" id="brightnessValue">0</span>
                </div>
                <div class="editor-control-group">
                    <span class="editor-control-label">Contrast</span>
                    <input type="range" id="contrastSlider" class="editor-slider" min="-100" max="100" value="0">
                    <span class="slider-value" id="contrastValue">0</span>
                </div>
            </div>
            <div class="editor-control-row">
                <button class="editor-btn editor-btn-icon" id="rotateLeft" title="Rotate Left">&#8634;</button>
                <button class="editor-btn editor-btn-icon" id="rotateRight" title="Rotate Right">&#8635;</button>
                <button class="editor-btn" id="toggleCrop">Crop</button>
                <button class="editor-btn" id="applyCrop" style="display: none;">Apply Crop</button>
            </div>
        </div>
    </div>

    <script>
        // Initialize
        const photos = {
            before: [],
            signoff: [],
            after: []
        };

        // Email recipients array
        let emailRecipients = [];

        // Add email recipient
        function addEmailRecipient() {
            const input = document.getElementById('emailInput');
            const email = input.value.trim();

            if (!email) {
                return;
            }

            // Basic email validation
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(email)) {
                showAlert('Invalid Email', 'Please enter a valid email address.');
                return;
            }

            // Check for duplicates
            if (emailRecipients.includes(email.toLowerCase())) {
                showAlert('Duplicate', 'This email address has already been added.');
                return;
            }

            emailRecipients.push(email.toLowerCase());
            input.value = '';
            renderRecipientList();
            autoSave();
        }

        // Remove email recipient
        function removeEmailRecipient(index) {
            emailRecipients.splice(index, 1);
            renderRecipientList();
            autoSave();
        }

        // Render the recipient list
        function renderRecipientList() {
            const container = document.getElementById('recipientListContainer');
            const list = document.getElementById('recipientList');

            if (emailRecipients.length === 0) {
                container.style.display = 'none';
                list.innerHTML = '';
                return;
            }

            container.style.display = 'block';
            list.innerHTML = emailRecipients.map((email, index) =>
                `<span class="recipient-tag">
                    ${email}
                    <button type="button" class="remove-btn" onclick="removeEmailRecipient(${index})" title="Remove">&times;</button>
                </span>`
            ).join('');
        }

        // Get semicolon-separated email list
        function getEmailList() {
            return emailRecipients.join('; ');
        }

        // Allow adding recipient with Enter key
        document.addEventListener('DOMContentLoaded', function() {
            const emailInput = document.getElementById('emailInput');
            if (emailInput) {
                emailInput.addEventListener('keypress', function(e) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addEmailRecipient();
                    }
                });
            }
        });

        // Set today's date
        document.getElementById('workDate').valueAsDate = new Date();

        // Auto-save to localStorage
        function autoSave() {
            // Preserve existing data (like signature) that may be saved separately
            const existingData = JSON.parse(localStorage.getItem('kompassEOD') || '{}');

            const data = {
                ...existingData, // Preserve signature and any other existing fields
                storeNumber: document.getElementById('storeNumber').value,
                date: document.getElementById('workDate').value,
                leadName: document.getElementById('leadName').value,
                checkInManager: document.getElementById('checkInManager').value,
                checkOutManager: document.getElementById('checkOutManager').value,
                commodities: document.getElementById('commodities').value,
                issue: document.getElementById('issue').value,
                tempSolution: document.getElementById('tempSolution').value,
                notes: document.getElementById('notes').value,
                emailRecipients: emailRecipients,
                hotlineYes: document.getElementById('hotlineYes').checked,
                hotlineNo: document.getElementById('hotlineNo').checked,
                resolvedYes: document.getElementById('resolvedYes').checked,
                resolvedNo: document.getElementById('resolvedNo').checked,
                resolvedNA: document.getElementById('resolvedNA').checked,
                prodYes: document.getElementById('prodYes').checked,
                prodNo: document.getElementById('prodNo').checked,
                siYes: document.getElementById('siYes').checked,
                siNo: document.getElementById('siNo').checked,
                beforeComplete: document.getElementById('beforeComplete')?.checked || false,
                signoffComplete: document.getElementById('signoffComplete')?.checked || false,
                afterComplete: document.getElementById('afterComplete')?.checked || false,
                addRetailOdysseyTeam: document.getElementById('addRetailOdysseyTeam')?.checked || false,
                photos: photos
            };
            localStorage.setItem('kompassEOD', JSON.stringify(data));
        }

        // Load saved data
        function loadSaved() {
            const saved = localStorage.getItem('kompassEOD');
            if (saved) {
                const data = JSON.parse(saved);
                document.getElementById('storeNumber').value = data.storeNumber || '';
                document.getElementById('workDate').value = data.date || '';
                document.getElementById('leadName').value = data.leadName || '';
                document.getElementById('checkInManager').value = data.checkInManager || '';
                document.getElementById('checkOutManager').value = data.checkOutManager || '';
                document.getElementById('commodities').value = data.commodities || '';
                document.getElementById('issue').value = data.issue || '';
                document.getElementById('tempSolution').value = data.tempSolution || '';
                document.getElementById('notes').value = data.notes || '';

                // Load email recipients (support both old emailTo and new emailRecipients format)
                if (data.emailRecipients && Array.isArray(data.emailRecipients)) {
                    emailRecipients = data.emailRecipients;
                } else if (data.emailTo) {
                    // Migrate old single email to new array format
                    emailRecipients = [data.emailTo];
                }
                renderRecipientList();

                if (data.hotlineYes) {
                    document.getElementById('hotlineYes').checked = true;
                    document.getElementById('hotlineDetails').style.display = 'block';
                }
                if (data.hotlineNo) document.getElementById('hotlineNo').checked = true;
                if (data.resolvedYes) document.getElementById('resolvedYes').checked = true;
                if (data.resolvedNo) {
                    document.getElementById('resolvedNo').checked = true;
                    document.getElementById('tempSolutionField').style.display = 'block';
                }
                if (data.resolvedNA) document.getElementById('resolvedNA').checked = true;
                if (data.prodYes) document.getElementById('prodYes').checked = true;
                if (data.prodNo) document.getElementById('prodNo').checked = true;
                if (data.siYes) document.getElementById('siYes').checked = true;
                if (data.siNo) document.getElementById('siNo').checked = true;

                if (typeof data.beforeComplete === 'boolean') {
                    document.getElementById('beforeComplete').checked = data.beforeComplete;
                }
                if (typeof data.signoffComplete === 'boolean') {
                    document.getElementById('signoffComplete').checked = data.signoffComplete;
                }
                if (typeof data.afterComplete === 'boolean') {
                    document.getElementById('afterComplete').checked = data.afterComplete;
                }
                if (typeof data.addRetailOdysseyTeam === 'boolean') {
                    document.getElementById('addRetailOdysseyTeam').checked = data.addRetailOdysseyTeam;
                }

                if (data.photos) {
                    // Deduplicate photos when loading (clean up any existing duplicates)
                    const deduplicatePhotos = (photoArray) => {
                        if (!Array.isArray(photoArray)) return [];
                        const seen = new Set();
                        return photoArray.filter(photo => {
                            const prefix = photo.substring(0, 1000);
                            if (seen.has(prefix)) return false;
                            seen.add(prefix);
                            return true;
                        });
                    };

                    photos.before = deduplicatePhotos(data.photos.before);
                    photos.signoff = deduplicatePhotos(data.photos.signoff);
                    photos.after = deduplicatePhotos(data.photos.after);

                    renderPhotos('before');
                    renderPhotos('signoff');
                    renderPhotos('after');

                    // Save back any cleaned up duplicates
                    if (photos.before.length !== (data.photos.before?.length || 0) ||
                        photos.signoff.length !== (data.photos.signoff?.length || 0) ||
                        photos.after.length !== (data.photos.after?.length || 0)) {
                        console.log('Cleaned up duplicate photos');
                        autoSave();
                    }
                }
            }
        }

        // Add event listeners for auto-save
        document.querySelectorAll('input, textarea').forEach(el => {
            el.addEventListener('change', autoSave);
            el.addEventListener('input', autoSave);
        });

        // Toggle functions
        function toggleRadio(groupName, clickedBox) {
            const checkboxes = document.querySelectorAll(`input[name="${groupName}"]`);
            if (clickedBox && clickedBox.checked) {
                // Uncheck all other checkboxes in the group
                checkboxes.forEach(box => {
                    if (box !== clickedBox) box.checked = false;
                });
            }
            autoSave();
        }

        function toggleHotline(checkbox) {
            const yes = document.getElementById('hotlineYes');
            const no = document.getElementById('hotlineNo');
            const details = document.getElementById('hotlineDetails');

            if (checkbox.id === 'hotlineYes' && checkbox.checked) {
                no.checked = false;
                details.style.display = 'block';
            } else if (checkbox.id === 'hotlineNo' && checkbox.checked) {
                yes.checked = false;
                details.style.display = 'none';
            }
            autoSave();
        }

        function toggleResolved(checkbox) {
            const yes = document.getElementById('resolvedYes');
            const no = document.getElementById('resolvedNo');
            const na = document.getElementById('resolvedNA');
            const tempField = document.getElementById('tempSolutionField');

            if (checkbox.checked) {
                [yes, no, na].forEach(cb => {
                    if (cb !== checkbox) cb.checked = false;
                });
            }

            tempField.style.display = no.checked ? 'block' : 'none';
            autoSave();
        }

        // Check if a photo already exists in the array (compare first 1000 chars to avoid expensive full comparison)
        function isPhotoAlreadyAdded(photoArray, newPhoto) {
            const newPhotoPrefix = newPhoto.substring(0, 1000);
            return photoArray.some(existing => existing.substring(0, 1000) === newPhotoPrefix);
        }

        // Processing guard to prevent duplicate uploads from rapid event firing
        const photoProcessingGuard = {};

        // Photo handling with orientation correction and HEIC support
        // Auto-check checkbox when photo is added, auto-uncheck when all photos removed
        function updatePhotoCheckbox(type) {
            const checkboxMap = {
                'before': 'beforeComplete',
                'after': 'afterComplete',
                'signoff': 'signoffComplete'
            };
            const checkboxId = checkboxMap[type];
            if (checkboxId) {
                const checkbox = document.getElementById(checkboxId);
                if (checkbox) {
                    checkbox.checked = photos[type].length > 0;
                }
            }
        }

        async function handlePhoto(input, type) {
            // Prevent concurrent processing for the same type (fixes duplicate uploads)
            if (photoProcessingGuard[type]) {
                console.log('Skipping concurrent photo processing for:', type);
                return;
            }
            photoProcessingGuard[type] = true;

            const files = input.files;
            if (!files || files.length === 0) {
                photoProcessingGuard[type] = false;
                return;
            }

            // Clear input immediately to prevent re-firing
            const fileList = Array.from(files);
            input.value = '';

            for (let file of fileList) {
                try {
                    let processedFile = file;

                    // Convert HEIC files to JPEG first
                    if (isHeicFile(file)) {
                        try {
                            processedFile = await convertHeicToJpeg(file);
                            console.log('HEIC file converted to JPEG');
                        } catch (heicError) {
                            console.error('HEIC conversion failed:', heicError);
                            showAlert('Could not convert HEIC image. Please try a different photo or convert it to JPEG first.');
                            continue;
                        }
                    }

                    // Process image with orientation correction
                    const correctedDataUrl = await processImageWithOrientation(processedFile);
                    // Only add if not a duplicate
                    if (!isPhotoAlreadyAdded(photos[type], correctedDataUrl)) {
                        photos[type].push(correctedDataUrl);
                        renderPhotos(type);
                        updatePhotoCheckbox(type);
                        autoSave();
                    } else {
                        console.log('Skipping duplicate photo');
                    }
                } catch (error) {
                    console.error('Error processing image:', error);
                    // Fallback to basic loading if orientation correction fails
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        // Only add if not a duplicate
                        if (!isPhotoAlreadyAdded(photos[type], e.target.result)) {
                            photos[type].push(e.target.result);
                            renderPhotos(type);
                            updatePhotoCheckbox(type);
                            autoSave();
                        } else {
                            console.log('Skipping duplicate photo');
                        }
                    };
                    reader.readAsDataURL(file);
                }
            }
            photoProcessingGuard[type] = false;
        }

        // Check if a file is HEIC format
        function isHeicFile(file) {
            const name = file.name.toLowerCase();
            const type = file.type.toLowerCase();
            return name.endsWith('.heic') || name.endsWith('.heif') ||
                   type === 'image/heic' || type === 'image/heif';
        }

        // Convert HEIC file to JPEG blob
        async function convertHeicToJpeg(file) {
            try {
                const blob = await heic2any({
                    blob: file,
                    toType: 'image/jpeg',
                    quality: 0.92
                });
                // heic2any can return a single blob or an array (for multi-image HEIC files)
                const resultBlob = Array.isArray(blob) ? blob[0] : blob;
                // Create a new File object with the converted blob
                return new File([resultBlob], file.name.replace(/\.heic$/i, '.jpg').replace(/\.heif$/i, '.jpg'), {
                    type: 'image/jpeg'
                });
            } catch (error) {
                console.error('HEIC conversion error:', error);
                throw new Error('Failed to convert HEIC image: ' + error.message);
            }
        }

        // Process image and correct orientation using canvas
        async function processImageWithOrientation(file) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    // Create canvas to draw the properly oriented image
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');

                    // Set canvas dimensions to match image
                    canvas.width = img.naturalWidth;
                    canvas.height = img.naturalHeight;

                    // Draw the image - modern browsers handle EXIF orientation automatically
                    ctx.drawImage(img, 0, 0);

                    // Convert to high-quality JPEG
                    const dataUrl = canvas.toDataURL('image/jpeg', 0.92);
                    resolve(dataUrl);
                };
                img.onerror = reject;

                // Create object URL to load the image
                img.src = URL.createObjectURL(file);
            });
        }

        function renderPhotos(type) {
            const container = document.getElementById(`preview${type.charAt(0).toUpperCase() + type.slice(1)}`);
            container.innerHTML = '';

            photos[type].forEach((photo, index) => {
                const item = document.createElement('div');
                item.className = 'photo-item';
                // Add edit button and clickable image only for signoff photos
                const isSignoff = type === 'signoff';
                const editBtn = isSignoff
                    ? `<button class="photo-edit" onclick="openImageEditor(${index})" title="Edit">&#9998;</button>`
                    : '';
                const imgClick = isSignoff
                    ? `onclick="openImageEditor(${index})" style="cursor: pointer;" title="Tap to edit"`
                    : '';
                item.innerHTML = `
                    <img src="${photo}" alt="${type} photo" ${imgClick}>
                    ${editBtn}
                    <button class="photo-remove" onclick="removePhoto('${type}', ${index})">x</button>
                `;
                container.appendChild(item);
            });
        }

        function removePhoto(type, index) {
            photos[type].splice(index, 1);
            renderPhotos(type);
            updatePhotoCheckbox(type);
            autoSave();
        }

        // Signature handling
        const canvas = document.getElementById('signaturePad');
        const ctx = canvas.getContext('2d');
        const fsOverlay = document.getElementById('signatureFullOverlay');
        const fsCanvas = document.getElementById('sigFsCanvas');
        const fsCtx = fsCanvas.getContext('2d');
        let fsDrawing = false, fsLastX = 0, fsLastY = 0;

        function openSignature() {
            fsOverlay.classList.add('show');
            resizeFsCanvas();

            // Load existing signature
            const saved = localStorage.getItem('kompassEOD');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.signature) {
                    const img = new Image();
                    img.onload = () => {
                        const scale = Math.min(fsCanvas.width / img.width, fsCanvas.height / img.height);
                        const dw = img.width * scale;
                        const dh = img.height * scale;
                        const dx = (fsCanvas.width - dw) / 2;
                        const dy = (fsCanvas.height - dh) / 2;
                        fsCtx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);
                    };
                    img.src = data.signature;
                }
            }
        }

        function resizeFsCanvas() {
            const toolbar = fsOverlay.querySelector('.sig-toolbar');
            const toolbarH = toolbar ? toolbar.offsetHeight : 0;
            fsCanvas.width = window.innerWidth;
            fsCanvas.height = window.innerHeight - toolbarH;
        }

        function fsStart(e) {
            fsDrawing = true;
            const rect = fsCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            fsLastX = touch.clientX - rect.left;
            fsLastY = touch.clientY - rect.top;
        }

        function fsDraw(e) {
            if (!fsDrawing) return;
            e.preventDefault();
            const rect = fsCanvas.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            fsCtx.beginPath();
            fsCtx.moveTo(fsLastX, fsLastY);
            fsCtx.lineTo(x, y);
            fsCtx.strokeStyle = '#000';
            fsCtx.lineWidth = 3;
            fsCtx.lineCap = 'round';
            fsCtx.lineJoin = 'round';
            fsCtx.stroke();
            fsLastX = x;
            fsLastY = y;
        }

        function fsStop() {
            fsDrawing = false;
        }

        fsCanvas.addEventListener('mousedown', fsStart);
        fsCanvas.addEventListener('mousemove', fsDraw);
        fsCanvas.addEventListener('mouseup', fsStop);
        fsCanvas.addEventListener('mouseout', fsStop);
        fsCanvas.addEventListener('touchstart', fsStart, { passive: false });
        fsCanvas.addEventListener('touchmove', fsDraw, { passive: false });
        fsCanvas.addEventListener('touchend', fsStop);

        document.getElementById('sigClear').addEventListener('click', () => {
            fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);
        });

        document.getElementById('sigAccept').addEventListener('click', () => {
            // Copy to storage canvas
            canvas.width = fsCanvas.width;
            canvas.height = fsCanvas.height;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(fsCanvas, 0, 0);

            // Save and update preview
            const data = JSON.parse(localStorage.getItem('kompassEOD') || '{}');
            data.signature = canvas.toDataURL('image/png');
            localStorage.setItem('kompassEOD', JSON.stringify(data));

            updateSignaturePreview();
            fsOverlay.classList.remove('show');
        });

        document.getElementById('sigClose').addEventListener('click', () => {
            fsOverlay.classList.remove('show');
        });

        // Signature photo loading
        document.getElementById('sigLoadPhoto').addEventListener('click', () => {
            document.getElementById('signaturePhotoInput').click();
        });

        document.getElementById('signaturePhotoInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                let processedFile = file;

                // Convert HEIC files to JPEG first
                if (isHeicFile(file)) {
                    try {
                        processedFile = await convertHeicToJpeg(file);
                        console.log('Signature HEIC file converted to JPEG');
                    } catch (heicError) {
                        console.error('HEIC conversion failed:', heicError);
                        showAlert('Could not convert HEIC image. Please try a different photo or convert it to JPEG first.');
                        e.target.value = '';
                        return;
                    }
                }

                // Load and draw the image onto the signature canvas
                const img = new Image();
                img.onload = () => {
                    // Clear the canvas first
                    fsCtx.clearRect(0, 0, fsCanvas.width, fsCanvas.height);

                    // Calculate scaling to fit the image within the canvas while maintaining aspect ratio
                    const scale = Math.min(
                        (fsCanvas.width * 0.9) / img.width,
                        (fsCanvas.height * 0.9) / img.height
                    );
                    const dw = img.width * scale;
                    const dh = img.height * scale;
                    const dx = (fsCanvas.width - dw) / 2;
                    const dy = (fsCanvas.height - dh) / 2;

                    // Draw white background behind the image (in case it has transparency)
                    fsCtx.fillStyle = '#ffffff';
                    fsCtx.fillRect(dx, dy, dw, dh);

                    // Draw the signature image
                    fsCtx.drawImage(img, 0, 0, img.width, img.height, dx, dy, dw, dh);
                };
                img.onerror = () => {
                    showAlert('Could not load the selected image. Please try a different file.');
                };
                img.src = URL.createObjectURL(processedFile);
            } catch (error) {
                console.error('Error loading signature photo:', error);
                showAlert('Error loading signature photo. Please try again.');
            }

            e.target.value = ''; // Reset the input
        });

        function updateSignaturePreview() {
            const preview = document.getElementById('signaturePreview');
            const saved = localStorage.getItem('kompassEOD');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.signature) {
                    preview.innerHTML = `<img src="${data.signature}" alt="Signature">`;
                    return;
                }
            }
            preview.textContent = 'Tap "Sign" to add signature';
        }

        // Camera handling for photos
        const cameraOverlay = document.getElementById('cameraFullOverlay');
        const cameraVideo = document.getElementById('cameraVideo');
        const captureCanvas = document.getElementById('captureCanvas');
        const captureButton = document.getElementById('captureButton');
        const flashToggle = document.getElementById('flashToggle');
        const flashStatus = document.getElementById('flashStatus');
        const photoCount = document.getElementById('photoCount');
        const cameraClose = document.getElementById('cameraClose');

        let cameraStream = null;
        let flashEnabled = false;
        let tempPhotoCount = 0;
        let currentCameraType = 'signoff';
        let captureInProgress = false;

        async function openPhotoCamera(type) {
            currentCameraType = type;
            await openCameraOverlay(false);
        }

        async function openSignoffCamera() {
            currentCameraType = 'signoff';
            await openCameraOverlay(true);
        }

        async function openCameraOverlay(multiplePhotos) {
            try {
                cameraOverlay.classList.add('show');
                tempPhotoCount = 0;
                updatePhotoCount();

                // Request camera with flash support
                const constraints = {
                    video: {
                        facingMode: 'environment',
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };

                cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraVideo.srcObject = cameraStream;

                // Check if flash is supported
                const track = cameraStream.getVideoTracks()[0];
                const capabilities = track.getCapabilities();

                if (!capabilities.torch) {
                    flashToggle.style.display = 'none';
                } else {
                    flashToggle.style.display = 'flex';
                }
            } catch (error) {
                console.error('Error accessing camera:', error);
                alert('Could not access camera. Please make sure you have granted camera permissions.');
                cameraOverlay.classList.remove('show');
            }
        }

        function updatePhotoCount() {
            const count = photos[currentCameraType].length + tempPhotoCount;
            photoCount.textContent = `${count} photo${count !== 1 ? 's' : ''}`;
        }

        flashToggle.addEventListener('click', async () => {
            if (!cameraStream) return;

            flashEnabled = !flashEnabled;
            const track = cameraStream.getVideoTracks()[0];

            try {
                await track.applyConstraints({
                    advanced: [{ torch: flashEnabled }]
                });

                flashStatus.textContent = flashEnabled ? 'On' : 'Off';
                flashToggle.classList.toggle('active', flashEnabled);
            } catch (error) {
                console.error('Error toggling flash:', error);
                alert('Flash control not supported on this device.');
            }
        });

        captureButton.addEventListener('click', () => {
            if (!cameraStream || captureInProgress) return;
            captureInProgress = true;

            // Set canvas size to match video
            captureCanvas.width = cameraVideo.videoWidth;
            captureCanvas.height = cameraVideo.videoHeight;

            // Draw the video frame to canvas
            const captureCtx = captureCanvas.getContext('2d');
            captureCtx.drawImage(cameraVideo, 0, 0);

            // Convert to data URL with high quality
            const photoData = captureCanvas.toDataURL('image/jpeg', 0.95);
            photos[currentCameraType].push(photoData);
            tempPhotoCount++;

            renderPhotos(currentCameraType);
            updatePhotoCount();
            autoSave();

            // Visual feedback
            captureCanvas.style.display = 'block';
            setTimeout(() => {
                captureCanvas.style.display = 'none';
            }, 100);

            // For single photo types (before/after), close camera after capture
            if (currentCameraType === 'before' || currentCameraType === 'after') {
                setTimeout(() => {
                    closeCameraOverlay();
                    captureInProgress = false;
                }, 300);
            } else {
                // Re-enable capture for multi-photo mode after brief delay
                setTimeout(() => {
                    captureInProgress = false;
                }, 500);
            }
        });

        cameraClose.addEventListener('click', () => {
            closeCameraOverlay();
        });

        function closeCameraOverlay() {
            captureInProgress = false;
            if (cameraStream) {
                const tracks = cameraStream.getTracks();
                tracks.forEach(track => track.stop());
                cameraStream = null;
            }

            flashEnabled = false;
            flashStatus.textContent = 'Off';
            flashToggle.classList.remove('active');
            cameraOverlay.classList.remove('show');
        }

        // Image Editor functionality
        const imageEditorOverlay = document.getElementById('imageEditorOverlay');
        const editorCanvas = document.getElementById('editorCanvas');
        const editorCtx = editorCanvas.getContext('2d');
        const editorCanvasContainer = document.getElementById('editorCanvasContainer');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const contrastSlider = document.getElementById('contrastSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const contrastValue = document.getElementById('contrastValue');
        const cropOverlay = document.getElementById('cropOverlay');

        let editorOriginalImage = null;
        let editorCurrentPhotoIndex = -1;
        let editorRotation = 0;
        let editorBrightness = 0;
        let editorContrast = 0;
        let cropMode = false;

        // Polygon crop variables
        let polygonPoints = []; // Array of {x, y} coordinates
        let isDragging = false;
        let dragPointIndex = -1;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPoint = null;

        const cropSvg = document.getElementById('cropSvg');
        const cropMaskPolygon = document.getElementById('cropMaskPolygon');
        const cropPolygonOutline = document.getElementById('cropPolygonOutline');
        const cropHandlesContainer = document.getElementById('cropHandlesContainer');

        function openImageEditor(photoIndex) {
            editorCurrentPhotoIndex = photoIndex;
            const photoData = photos.signoff[photoIndex];

            // Reset all editor state
            editorRotation = 0;
            editorBrightness = 0;
            editorContrast = 0;
            brightnessSlider.value = 0;
            contrastSlider.value = 0;
            brightnessValue.textContent = '0';
            contrastValue.textContent = '0';
            cropMode = false;
            document.getElementById('toggleCrop').classList.remove('active');
            document.getElementById('applyCrop').style.display = 'none';
            cropOverlay.classList.remove('active');

            // Load the image
            editorOriginalImage = new Image();
            editorOriginalImage.onload = () => {
                imageEditorOverlay.classList.add('show');
                renderEditorCanvas();
            };
            editorOriginalImage.src = photoData;
        }

        function renderEditorCanvas() {
            if (!editorOriginalImage) return;

            const img = editorOriginalImage;
            const container = editorCanvasContainer;

            // Calculate rotated dimensions
            const isRotated90 = Math.abs(editorRotation % 180) === 90;
            const srcWidth = isRotated90 ? img.height : img.width;
            const srcHeight = isRotated90 ? img.width : img.height;

            // Scale to fit container while maintaining aspect ratio
            const maxWidth = container.clientWidth - 20;
            const maxHeight = container.clientHeight - 20;
            const scale = Math.min(maxWidth / srcWidth, maxHeight / srcHeight, 1);

            const displayWidth = Math.floor(srcWidth * scale);
            const displayHeight = Math.floor(srcHeight * scale);

            editorCanvas.width = displayWidth;
            editorCanvas.height = displayHeight;

            // Clear and draw with transformations
            editorCtx.save();
            editorCtx.clearRect(0, 0, displayWidth, displayHeight);

            // Apply brightness and contrast via filter
            const brightnessPercent = 100 + editorBrightness;
            const contrastPercent = 100 + editorContrast;
            editorCtx.filter = `brightness(${brightnessPercent}%) contrast(${contrastPercent}%)`;

            // Center and rotate
            editorCtx.translate(displayWidth / 2, displayHeight / 2);
            editorCtx.rotate((editorRotation * Math.PI) / 180);

            // Draw the image centered
            const drawWidth = isRotated90 ? displayHeight : displayWidth;
            const drawHeight = isRotated90 ? displayWidth : displayHeight;
            editorCtx.drawImage(img, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);

            editorCtx.restore();

            // Update crop overlay if active
            if (cropMode) {
                updateCropOverlay();
            }
        }

        function initCrop() {
            const canvasRect = editorCanvas.getBoundingClientRect();
            const containerRect = editorCanvasContainer.getBoundingClientRect();

            // Position crop overlay over canvas
            cropOverlay.style.left = (canvasRect.left - containerRect.left) + 'px';
            cropOverlay.style.top = (canvasRect.top - containerRect.top) + 'px';
            cropOverlay.style.width = canvasRect.width + 'px';
            cropOverlay.style.height = canvasRect.height + 'px';

            // Initialize polygon points with 4 corners (can add more points later)
            const margin = Math.min(canvasRect.width, canvasRect.height) * 0.1;
            polygonPoints = [
                { x: margin, y: margin },                                    // Top-left
                { x: canvasRect.width - margin, y: margin },                 // Top-right
                { x: canvasRect.width - margin, y: canvasRect.height - margin }, // Bottom-right
                { x: margin, y: canvasRect.height - margin }                 // Bottom-left
            ];

            updateCropOverlay();
        }

        function getPolygonPointsString() {
            return polygonPoints.map(p => `${p.x},${p.y}`).join(' ');
        }

        function updateCropOverlay() {
            const pointsString = getPolygonPointsString();

            // Update SVG polygon for mask and outline
            cropMaskPolygon.setAttribute('points', pointsString);
            cropPolygonOutline.setAttribute('points', pointsString);

            // Update handle positions
            renderCropHandles();
        }

        function renderCropHandles() {
            // Clear existing handles
            cropHandlesContainer.innerHTML = '';

            const overlayWidth = parseFloat(cropOverlay.style.width);
            const overlayHeight = parseFloat(cropOverlay.style.height);

            // Create a handle for each polygon point
            polygonPoints.forEach((point, index) => {
                const handle = document.createElement('div');
                handle.className = 'crop-handle';
                handle.dataset.pointIndex = index;
                handle.style.left = point.x + 'px';
                handle.style.top = point.y + 'px';

                // Add point number label
                const label = document.createElement('span');
                label.className = 'crop-handle-label';
                label.textContent = (index + 1).toString();
                handle.appendChild(label);

                cropHandlesContainer.appendChild(handle);
            });
        }

        // Add a new point on line between two existing points
        function addPointBetween(index1, index2, x, y) {
            const insertIndex = Math.max(index1, index2);
            polygonPoints.splice(insertIndex, 0, { x, y });
            updateCropOverlay();
        }

        // Remove a point (minimum 3 points required for a polygon)
        function removePoint(index) {
            if (polygonPoints.length > 3) {
                polygonPoints.splice(index, 1);
                updateCropOverlay();
            }
        }

        // Crop drag handlers
        function handleCropStart(e) {
            if (!cropMode) return;

            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = cropOverlay.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const target = e.target;
            if (target.classList.contains('crop-handle')) {
                dragPointIndex = parseInt(target.dataset.pointIndex);
                dragStartX = x;
                dragStartY = y;
                dragStartPoint = { ...polygonPoints[dragPointIndex] };
                isDragging = true;
            }
        }

        function handleCropMove(e) {
            if (!isDragging || !cropMode || dragPointIndex < 0) return;

            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = cropOverlay.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const overlayWidth = rect.width;
            const overlayHeight = rect.height;

            // Update the point position, constrained to overlay bounds
            polygonPoints[dragPointIndex] = {
                x: Math.max(0, Math.min(overlayWidth, dragStartPoint.x + (x - dragStartX))),
                y: Math.max(0, Math.min(overlayHeight, dragStartPoint.y + (y - dragStartY)))
            };

            updateCropOverlay();
        }

        function handleCropEnd() {
            isDragging = false;
            dragPointIndex = -1;
            dragStartPoint = null;
        }

        // Find closest point on polygon edge to a given point
        function findClosestEdgePoint(x, y) {
            let minDist = Infinity;
            let closestPoint = null;
            let edgeIndex = -1;

            for (let i = 0; i < polygonPoints.length; i++) {
                const p1 = polygonPoints[i];
                const p2 = polygonPoints[(i + 1) % polygonPoints.length];

                // Project point onto line segment
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const len2 = dx * dx + dy * dy;

                if (len2 === 0) continue;

                let t = ((x - p1.x) * dx + (y - p1.y) * dy) / len2;
                t = Math.max(0, Math.min(1, t));

                const projX = p1.x + t * dx;
                const projY = p1.y + t * dy;
                const dist = Math.hypot(x - projX, y - projY);

                if (dist < minDist) {
                    minDist = dist;
                    closestPoint = { x: projX, y: projY };
                    edgeIndex = i;
                }
            }

            return { point: closestPoint, distance: minDist, edgeIndex };
        }

        // Handle double-click to add/remove points
        function handleCropDoubleClick(e) {
            if (!cropMode) return;

            e.preventDefault();
            const touch = e.touches ? e.touches[0] : e;
            const rect = cropOverlay.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const target = e.target;

            // Double-click on handle to remove point (if more than 3 points)
            if (target.classList.contains('crop-handle')) {
                const pointIndex = parseInt(target.dataset.pointIndex);
                if (polygonPoints.length > 3) {
                    polygonPoints.splice(pointIndex, 1);
                    updateCropOverlay();
                }
                return;
            }

            // Double-click on overlay to add a point on nearest edge
            const { point, distance, edgeIndex } = findClosestEdgePoint(x, y);
            if (distance < 30 && point) { // Within 30px of an edge
                // Insert point after the first point of the edge
                polygonPoints.splice(edgeIndex + 1, 0, point);
                updateCropOverlay();
            }
        }

        // Add crop event listeners
        cropOverlay.addEventListener('mousedown', handleCropStart);
        cropOverlay.addEventListener('touchstart', handleCropStart, { passive: false });
        document.addEventListener('mousemove', handleCropMove);
        document.addEventListener('touchmove', handleCropMove, { passive: false });
        document.addEventListener('mouseup', handleCropEnd);
        document.addEventListener('touchend', handleCropEnd);
        cropOverlay.addEventListener('dblclick', handleCropDoubleClick);

        // Editor button handlers
        brightnessSlider.addEventListener('input', (e) => {
            editorBrightness = parseInt(e.target.value);
            brightnessValue.textContent = editorBrightness;
            renderEditorCanvas();
        });

        contrastSlider.addEventListener('input', (e) => {
            editorContrast = parseInt(e.target.value);
            contrastValue.textContent = editorContrast;
            renderEditorCanvas();
        });

        document.getElementById('rotateLeft').addEventListener('click', () => {
            editorRotation = (editorRotation - 90 + 360) % 360;
            renderEditorCanvas();
            if (cropMode) {
                setTimeout(initCrop, 50);
            }
        });

        document.getElementById('rotateRight').addEventListener('click', () => {
            editorRotation = (editorRotation + 90) % 360;
            renderEditorCanvas();
            if (cropMode) {
                setTimeout(initCrop, 50);
            }
        });

        document.getElementById('toggleCrop').addEventListener('click', () => {
            cropMode = !cropMode;
            document.getElementById('toggleCrop').classList.toggle('active', cropMode);
            document.getElementById('applyCrop').style.display = cropMode ? 'inline-block' : 'none';
            cropOverlay.classList.toggle('active', cropMode);

            if (cropMode) {
                setTimeout(initCrop, 50);
            }
        });

        // Perspective transform helper functions
        function solvePerspectiveMatrix(src, dst) {
            // Solve for the 3x3 perspective transformation matrix
            // that maps src points to dst points
            // Returns the matrix coefficients [a, b, c, d, e, f, g, h]
            // where the transform is:
            // x' = (ax + by + c) / (gx + hy + 1)
            // y' = (dx + ey + f) / (gx + hy + 1)

            const [p0, p1, p2, p3] = src;
            const [q0, q1, q2, q3] = dst;

            // Set up the system of equations
            const A = [
                [p0.x, p0.y, 1, 0, 0, 0, -q0.x * p0.x, -q0.x * p0.y],
                [0, 0, 0, p0.x, p0.y, 1, -q0.y * p0.x, -q0.y * p0.y],
                [p1.x, p1.y, 1, 0, 0, 0, -q1.x * p1.x, -q1.x * p1.y],
                [0, 0, 0, p1.x, p1.y, 1, -q1.y * p1.x, -q1.y * p1.y],
                [p2.x, p2.y, 1, 0, 0, 0, -q2.x * p2.x, -q2.x * p2.y],
                [0, 0, 0, p2.x, p2.y, 1, -q2.y * p2.x, -q2.y * p2.y],
                [p3.x, p3.y, 1, 0, 0, 0, -q3.x * p3.x, -q3.x * p3.y],
                [0, 0, 0, p3.x, p3.y, 1, -q3.y * p3.x, -q3.y * p3.y]
            ];
            const b = [q0.x, q0.y, q1.x, q1.y, q2.x, q2.y, q3.x, q3.y];

            // Solve using Gaussian elimination
            return gaussianElimination(A, b);
        }

        function gaussianElimination(A, b) {
            const n = A.length;
            const aug = A.map((row, i) => [...row, b[i]]);

            // Forward elimination
            for (let col = 0; col < n; col++) {
                // Find pivot
                let maxRow = col;
                for (let row = col + 1; row < n; row++) {
                    if (Math.abs(aug[row][col]) > Math.abs(aug[maxRow][col])) {
                        maxRow = row;
                    }
                }
                [aug[col], aug[maxRow]] = [aug[maxRow], aug[col]];

                // Eliminate column
                for (let row = col + 1; row < n; row++) {
                    const factor = aug[row][col] / aug[col][col];
                    for (let j = col; j <= n; j++) {
                        aug[row][j] -= factor * aug[col][j];
                    }
                }
            }

            // Back substitution
            const x = new Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = aug[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= aug[i][j] * x[j];
                }
                x[i] /= aug[i][i];
            }
            return x;
        }

        function applyPerspectiveTransform(srcCanvas, srcPoints, dstWidth, dstHeight) {
            // Create destination canvas
            const dstCanvas = document.createElement('canvas');
            dstCanvas.width = dstWidth;
            dstCanvas.height = dstHeight;
            const dstCtx = dstCanvas.getContext('2d');

            // Define destination rectangle corners
            const dstPoints = [
                { x: 0, y: 0 },
                { x: dstWidth, y: 0 },
                { x: dstWidth, y: dstHeight },
                { x: 0, y: dstHeight }
            ];

            // Get the inverse perspective transform (dst -> src)
            const matrix = solvePerspectiveMatrix(dstPoints, srcPoints);
            const [a, b, c, d, e, f, g, h] = matrix;

            // Get source image data
            const srcCtx = srcCanvas.getContext('2d');
            const srcImageData = srcCtx.getImageData(0, 0, srcCanvas.width, srcCanvas.height);
            const srcData = srcImageData.data;
            const srcW = srcCanvas.width;
            const srcH = srcCanvas.height;

            // Create destination image data
            const dstImageData = dstCtx.createImageData(dstWidth, dstHeight);
            const dstData = dstImageData.data;

            // Apply the transform with bilinear interpolation
            for (let dy = 0; dy < dstHeight; dy++) {
                for (let dx = 0; dx < dstWidth; dx++) {
                    // Apply inverse perspective transform
                    const denom = g * dx + h * dy + 1;
                    const sx = (a * dx + b * dy + c) / denom;
                    const sy = (d * dx + e * dy + f) / denom;

                    // Bilinear interpolation
                    if (sx >= 0 && sx < srcW - 1 && sy >= 0 && sy < srcH - 1) {
                        const x0 = Math.floor(sx);
                        const y0 = Math.floor(sy);
                        const x1 = x0 + 1;
                        const y1 = y0 + 1;
                        const xFrac = sx - x0;
                        const yFrac = sy - y0;

                        const idx00 = (y0 * srcW + x0) * 4;
                        const idx10 = (y0 * srcW + x1) * 4;
                        const idx01 = (y1 * srcW + x0) * 4;
                        const idx11 = (y1 * srcW + x1) * 4;
                        const dstIdx = (dy * dstWidth + dx) * 4;

                        for (let c = 0; c < 4; c++) {
                            const v00 = srcData[idx00 + c];
                            const v10 = srcData[idx10 + c];
                            const v01 = srcData[idx01 + c];
                            const v11 = srcData[idx11 + c];

                            const v = v00 * (1 - xFrac) * (1 - yFrac) +
                                      v10 * xFrac * (1 - yFrac) +
                                      v01 * (1 - xFrac) * yFrac +
                                      v11 * xFrac * yFrac;

                            dstData[dstIdx + c] = Math.round(v);
                        }
                    }
                }
            }

            dstCtx.putImageData(dstImageData, 0, 0);
            return dstCanvas;
        }

        function calculateOutputDimensions(points) {
            // Calculate the output dimensions based on the polygon
            // For a 4-point polygon, use the average of opposite edge lengths
            if (points.length === 4) {
                const topWidth = Math.hypot(points[1].x - points[0].x, points[1].y - points[0].y);
                const bottomWidth = Math.hypot(points[2].x - points[3].x, points[2].y - points[3].y);
                const leftHeight = Math.hypot(points[3].x - points[0].x, points[3].y - points[0].y);
                const rightHeight = Math.hypot(points[2].x - points[1].x, points[2].y - points[1].y);

                return {
                    width: Math.round((topWidth + bottomWidth) / 2),
                    height: Math.round((leftHeight + rightHeight) / 2)
                };
            }

            // For other polygons, use bounding box
            const xs = points.map(p => p.x);
            const ys = points.map(p => p.y);
            return {
                width: Math.round(Math.max(...xs) - Math.min(...xs)),
                height: Math.round(Math.max(...ys) - Math.min(...ys))
            };
        }

        document.getElementById('applyCrop').addEventListener('click', () => {
            if (!cropMode || polygonPoints.length < 3) return;

            // Get scale factors from overlay to canvas coordinates
            const canvasRect = editorCanvas.getBoundingClientRect();
            const scaleX = editorCanvas.width / canvasRect.width;
            const scaleY = editorCanvas.height / canvasRect.height;

            // Scale polygon points to canvas coordinates
            const scaledPoints = polygonPoints.map(p => ({
                x: p.x * scaleX,
                y: p.y * scaleY
            }));

            let croppedCanvas;

            if (scaledPoints.length === 4) {
                // For 4 points, use perspective transform
                const outputDims = calculateOutputDimensions(scaledPoints);
                croppedCanvas = applyPerspectiveTransform(
                    editorCanvas,
                    scaledPoints,
                    outputDims.width,
                    outputDims.height
                );
            } else {
                // For other point counts, clip to polygon shape
                const xs = scaledPoints.map(p => p.x);
                const ys = scaledPoints.map(p => p.y);
                const minX = Math.min(...xs);
                const minY = Math.min(...ys);
                const maxX = Math.max(...xs);
                const maxY = Math.max(...ys);
                const width = maxX - minX;
                const height = maxY - minY;

                croppedCanvas = document.createElement('canvas');
                croppedCanvas.width = width;
                croppedCanvas.height = height;
                const ctx = croppedCanvas.getContext('2d');

                // Create clipping path
                ctx.beginPath();
                ctx.moveTo(scaledPoints[0].x - minX, scaledPoints[0].y - minY);
                for (let i = 1; i < scaledPoints.length; i++) {
                    ctx.lineTo(scaledPoints[i].x - minX, scaledPoints[i].y - minY);
                }
                ctx.closePath();
                ctx.clip();

                // Draw the image
                ctx.drawImage(editorCanvas, -minX, -minY);
            }

            // Create a new image from the cropped canvas
            const croppedImage = new Image();
            croppedImage.onload = () => {
                editorOriginalImage = croppedImage;
                editorRotation = 0;

                // Exit crop mode
                cropMode = false;
                document.getElementById('toggleCrop').classList.remove('active');
                document.getElementById('applyCrop').style.display = 'none';
                cropOverlay.classList.remove('active');

                renderEditorCanvas();
            };
            croppedImage.src = croppedCanvas.toDataURL('image/jpeg', 0.95);
        });

        document.getElementById('editorReset').addEventListener('click', () => {
            // Reload original image
            const photoData = photos.signoff[editorCurrentPhotoIndex];
            editorRotation = 0;
            editorBrightness = 0;
            editorContrast = 0;
            brightnessSlider.value = 0;
            contrastSlider.value = 0;
            brightnessValue.textContent = '0';
            contrastValue.textContent = '0';
            cropMode = false;
            document.getElementById('toggleCrop').classList.remove('active');
            document.getElementById('applyCrop').style.display = 'none';
            cropOverlay.classList.remove('active');

            editorOriginalImage = new Image();
            editorOriginalImage.onload = () => {
                renderEditorCanvas();
            };
            editorOriginalImage.src = photoData;
        });

        document.getElementById('editorCancel').addEventListener('click', () => {
            imageEditorOverlay.classList.remove('show');
            editorOriginalImage = null;
            editorCurrentPhotoIndex = -1;
        });

        document.getElementById('editorSave').addEventListener('click', () => {
            if (editorCurrentPhotoIndex < 0) return;

            // Get the final image data URL
            const finalDataUrl = editorCanvas.toDataURL('image/jpeg', 0.95);

            // Update the photo in the array
            photos.signoff[editorCurrentPhotoIndex] = finalDataUrl;

            // Re-render and save
            renderPhotos('signoff');
            autoSave();

            // Close editor
            imageEditorOverlay.classList.remove('show');
            editorOriginalImage = null;
            editorCurrentPhotoIndex = -1;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            if (imageEditorOverlay.classList.contains('show')) {
                renderEditorCanvas();
                if (cropMode) {
                    setTimeout(initCrop, 50);
                }
            }
        });

        // Format helpers
        function getFormattedDate(isoDate) {
            if (!isoDate) {
                const d = new Date();
                isoDate = d.toISOString().split('T')[0];
            }
            const parts = isoDate.split('-');
            if (parts.length === 3) {
                const [y, m, d] = parts;
                const yy = y.slice(-2);
                return {
                    mmddyyyy: `${m}/${d}/${y}`,
                    mm_dd_yyyy: `${m}_${d}_${y}`,
                    dd_mm_yy: `${d} ${m} ${yy}`
                };
            }
            const today = new Date();
            const m = String(today.getMonth() + 1).padStart(2, '0');
            const d = String(today.getDate()).padStart(2, '0');
            const y = today.getFullYear();
            const yy = String(y).slice(-2);
            return {
                mmddyyyy: `${m}/${d}/${y}`,
                mm_dd_yyyy: `${m}_${d}_${y}`,
                dd_mm_yy: `${d} ${m} ${yy}`
            };
        }

        function getFormattedStoreNum(storeNum) {
            return String(storeNum || '').padStart(3, '0');
        }

        async function getSignatureDataURL() {
            const saved = localStorage.getItem('kompassEOD');
            if (saved) {
                const data = JSON.parse(saved);
                if (data.signature) {
                    // Auto-crop signature
                    const img = new Image();
                    await new Promise(resolve => {
                        img.onload = resolve;
                        img.src = data.signature;
                    });

                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = img.width;
                    tempCanvas.height = img.height;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(img, 0, 0);

                    const imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
                    const dataArray = imageData.data;

                    let minX = tempCanvas.width, minY = tempCanvas.height, maxX = 0, maxY = 0;
                    let isEmpty = true;

                    for (let y = 0; y < tempCanvas.height; y++) {
                        for (let x = 0; x < tempCanvas.width; x++) {
                            const alpha = dataArray[((y * tempCanvas.width) + x) * 4 + 3];
                            if (alpha > 0) {
                                isEmpty = false;
                                if (x < minX) minX = x;
                                if (x > maxX) maxX = x;
                                if (y < minY) minY = y;
                                if (y > maxY) maxY = y;
                            }
                        }
                    }

                    if (isEmpty) return '';

                    const padding = 10;
                    minX = Math.max(0, minX - padding);
                    minY = Math.max(0, minY - padding);
                    maxX = Math.min(tempCanvas.width, maxX + padding);
                    maxY = Math.min(tempCanvas.height, maxY + padding);

                    const cropWidth = maxX - minX;
                    const cropHeight = maxY - minY;

                    const cropCanvas = document.createElement('canvas');
                    cropCanvas.width = cropWidth;
                    cropCanvas.height = cropHeight;
                    const cropCtx = cropCanvas.getContext('2d');
                    cropCtx.drawImage(tempCanvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                    return cropCanvas.toDataURL('image/png');
                }
            }
            return '';
        }

        function pickYN(v) {
            if (typeof v === 'string') {
                const s = v.trim().toLowerCase();
                if (s.startsWith('y')) return 'Yes';
                if (s.startsWith('n')) return 'No';
            }
            return v ? 'Yes' : 'No';
        }

        function pickYNN(v) {
            if (typeof v === 'string') {
                const s = v.trim().toLowerCase();
                if (s === 'na' || s === 'n/a') return 'NA';
                if (s.startsWith('y')) return 'Yes';
                if (s.startsWith('n')) return 'No';
            }
            if (v === null || v === undefined) return 'NA';
            return v ? 'Yes' : 'No';
        }

        // Collect all data
        async function collectData() {
            const rawDate = document.getElementById('workDate').value;
            const dates = getFormattedDate(rawDate);
            const rawStoreNum = document.getElementById('storeNumber').value;
            const storeNumPadded = getFormattedStoreNum(rawStoreNum);

            const hotlineYes = document.getElementById('hotlineYes').checked;
            const resolvedValue = document.querySelector('input[name="resolved"]:checked')?.value || 'NA';

            return {
                LeadName: document.getElementById('leadName').value,
                DateMMDDYYYY: dates.mmddyyyy,
                DateForFilename: dates.mm_dd_yyyy,
                DateForPDFFilename: dates.dd_mm_yy,
                StoreNumber: rawStoreNum,
                StoreNumberPadded: storeNumPadded,
                CheckInManager: document.getElementById('checkInManager').value,
                CheckOutManager: document.getElementById('checkOutManager').value,
                CalledHotline: hotlineYes,
                IssueCommodities: hotlineYes ? document.getElementById('commodities').value : 'N/A',
                WhatIsIssue: hotlineYes ? document.getElementById('issue').value : 'N/A',
                IssueResolved: hotlineYes ? resolvedValue : 'NA',
                TempSolution: (hotlineYes && resolvedValue === 'No') ? document.getElementById('tempSolution').value : 'N/A',
                SignedOutPROD: document.getElementById('prodYes').checked,
                SignedOutSI: document.getElementById('siYes').checked,
                Notes: document.getElementById('notes').value,
                EmailTo: getEmailList(),
                BeforeComplete: document.getElementById('beforeComplete')?.checked || false,
                SignoffComplete: document.getElementById('signoffComplete')?.checked || false,
                AfterComplete: document.getElementById('afterComplete')?.checked || false,
                signatureDataURL: await getSignatureDataURL(),
                photos: photos
            };
        }

        // Generate Email
        async function generateEmail() {
            const loading = document.getElementById('loadingOverlay');
            loading.classList.add('show');

            try {
                const data = await collectData();

                // First, generate the PDF
                const pdfFilename = `FM${data.StoreNumberPadded} KOMPASS EOD ${data.DateForPDFFilename}.PDF`;

                try {
                    await generatePDFInternal(data, pdfFilename);
                } catch (pdfError) {
                    console.error('Error generating PDF:', pdfError);
                    loading.classList.remove('show');
                    showAlert('PDF Generation Error', 'Failed to generate PDF. You can still send the email, but you\'ll need to attach documents manually.<br><br>Error: ' + pdfError.message);
                    // Continue with email generation even if PDF fails
                }

                const notesOnly = document.getElementById('notesOnlyToggle').checked;

                let body = '';

                if (notesOnly) {
                    body = `

Notes:
${data.Notes || ''}
`;
                } else {
                    const beforeDone  = data.photos.before.length  > 0 || data.BeforeComplete;
                    const signoffDone = data.photos.signoff.length > 0 || data.SignoffComplete;
                    const afterDone   = data.photos.after.length   > 0 || data.AfterComplete;

                    body = `
Lead Name: ${data.LeadName || ''}
Date: ${data.DateMMDDYYYY || ''}
Store Number: ${data.StoreNumber || ''}

Before picture of KOMPASS cart taken: ${beforeDone ? 'Yes' : 'No'}
Manager checked in with: ${data.CheckInManager || ''}

Called KOMPASS Hotline: ${pickYN(data.CalledHotline)}
Commodities: ${data.IssueCommodities || 'N/A'}
Issue: ${data.WhatIsIssue || 'N/A'}
Issue resolved: ${data.IssueResolved || 'N/A'}
Temporary solution: ${data.TempSolution || 'N/A'}

Manager checked out with: ${data.CheckOutManager || ''}
Signed out in PROD: ${pickYN(data.SignedOutPROD)}
Signed out in SI: ${pickYN(data.SignedOutSI)}

After picture of KOMPASS cart taken: ${afterDone ? 'Yes' : 'No'}
Sign-off sheets photographed: ${signoffDone ? 'Yes' : 'No'}
Number of sign-off photos: ${data.photos.signoff.length}

Notes:
${data.Notes || ''}
`;
                }

                const to = data.EmailTo || '';
                let ccList = ['aiyana.natarisalazar@retailodyssey.com', 'tyson.gauthier@retailodyssey.com'];

                // Add Retail Odyssey Team emails if checkbox is checked
                if (document.getElementById('addRetailOdysseyTeam').checked) {
                    const retailOdysseyTeam = ['MAshabranner@retailodyssey.com', 'seth.newman@retailodyssey.com', 'tyson.gauthier@retailodyssey.com'];
                    ccList = ccList.concat(retailOdysseyTeam);
                    // Remove duplicates
                    ccList = [...new Set(ccList)];
                }

                // Use semicolons as separator (Outlook standard)
                const cc = ccList.join('; ');

                const subject = `KOMPASS EOD FM${data.StoreNumberPadded} ${data.DateMMDDYYYY}`;
                const mailtoUrl = `mailto:${encodeURIComponent(to)}?cc=${encodeURIComponent(cc)}&subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

                // Store email data for the various send methods
                window.pendingEmailData = { to, cc, subject, body, pdfFilename };

                loading.classList.remove('show');

                showEmailOptions(pdfFilename);
            } catch (error) {
                console.error('Error generating email:', error);
                loading.classList.remove('show');
                showAlert('Error', 'Failed to generate email: ' + error.message);
            }
        }

        // Internal PDF generation function (called by generateEmail)
        async function generatePDFInternal(data, filename) {
            console.log('Starting PDF generation...');

            // Check if PDFLib is loaded
            if (typeof PDFLib === 'undefined') {
                throw new Error('PDF library not loaded. Please refresh the page.');
            }

            console.log('Data collected:', data);

            // Load the PDF template - try multiple paths
            let pdfBytes;
            const pdfPaths = [
                'End Of Day Cover Sheet Form Editable Template (1).pdf',
                './End_Of_Day_Cover_Sheet_Form_Editable_Template_(1).pdf',
                'End%20Of%20Day%20Cover%20Sheet%20Form%20Editable%20Template%20(1).pdf'
            ];

            let loadError;
            for (let pdfUrl of pdfPaths) {
                try {
                    console.log('Trying to load PDF from:', pdfUrl);
                    const response = await fetch(pdfUrl);
                    if (response.ok) {
                        pdfBytes = await response.arrayBuffer();
                        console.log('PDF loaded successfully from:', pdfUrl);
                        break;
                    }
                } catch (e) {
                    loadError = e;
                    console.warn('Failed to load from:', pdfUrl, e);
                }
            }

            if (!pdfBytes) {
                throw new Error('PDF template not found. Please ensure "End Of Day Cover Sheet Form Editable Template (1).pdf" is in the same directory as this HTML file. Error: ' + (loadError ? loadError.message : 'Not found'));
            }

            console.log('Loading PDF document...');
            const pdfDoc = await PDFLib.PDFDocument.load(pdfBytes);
            console.log('Getting form...');
            const form = pdfDoc.getForm();

            console.log('Filling form fields...');
            // Fill form fields with error handling for each field
            try {
                form.getTextField('LeadName').setText(data.LeadName || '');
                form.getTextField('DateISO').setText(data.DateMMDDYYYY || '');
                form.getTextField('StoreNumber').setText(data.StoreNumber || '');
                form.getTextField('CheckInManager').setText(data.CheckInManager || '');
                form.getTextField('IssueCommodities').setText(data.IssueCommodities || '');
                form.getTextField('WhatIsIssue').setText(data.WhatIsIssue || '');
                form.getTextField('TempSolution').setText(data.TempSolution || '');
                form.getTextField('CheckOutManager').setText(data.CheckOutManager || '');
                console.log('Text fields filled successfully');
            } catch (e) {
                console.error('Error filling text fields:', e);
                throw new Error('Error filling text fields: ' + e.message);
            }

            console.log('Setting radio buttons...');
            // Radio buttons with error handling
            try {
                const beforeDone = data.photos.before.length > 0 || data.BeforeComplete;
                const signoffDone = data.photos.signoff.length > 0 || data.SignoffComplete;
                const afterDone = data.photos.after.length > 0 || data.AfterComplete;

                form.getRadioGroup('BeforePicPosted').select(pickYN(beforeDone));
                form.getRadioGroup('CalledHotline').select(pickYN(data.CalledHotline));
                form.getRadioGroup('IssueResolved').select(pickYNN(data.IssueResolved));
                form.getRadioGroup('SignedOutPROD').select(pickYN(data.SignedOutPROD));
                form.getRadioGroup('SignedOutSI').select(pickYN(data.SignedOutSI));
                form.getRadioGroup('SignoutSheetAttachedEmail').select(pickYN(signoffDone));
                form.getRadioGroup('SignoutSheetAttachedPROD').select(pickYN(signoffDone));
                form.getRadioGroup('AfterPicPosted').select(pickYN(afterDone));
                console.log('Radio buttons set successfully');
            } catch (e) {
                console.error('Error setting radio buttons:', e);
                throw new Error('Error setting radio buttons: ' + e.message);
            }

            console.log('Embedding signature...');
            // Embed signature
            if (data.signatureDataURL) {
                try {
                    const sigBytes = await fetch(data.signatureDataURL).then(r => r.arrayBuffer());
                    const sigImage = await pdfDoc.embedPng(sigBytes);

                    // Try to set as button image first
                    try {
                        form.getButton('LeadSignatureImage').setImage(sigImage);
                        console.log('Signature embedded as button image');
                    } catch (buttonError) {
                        console.warn('Could not set button image, trying alternative method:', buttonError);

                        // Alternative: Draw signature directly on the first page
                        const pages = pdfDoc.getPages();
                        const firstPage = pages[0];

                        // Adjust these coordinates based on where signature should appear on your form
                        const sigWidth = 150;
                        const sigHeight = 50;
                        const sigX = 400; // Adjust X position
                        const sigY = 100; // Adjust Y position

                        firstPage.drawImage(sigImage, {
                            x: sigX,
                            y: sigY,
                            width: sigWidth,
                            height: sigHeight,
                        });

                        console.log('Signature drawn directly on page');
                    }
                } catch (e) {
                    console.error('Error embedding signature:', e);
                    console.warn('Continuing without signature');
                }
            }

            console.log('Adding photo pages...');
            // Add photos to additional pages
            if (data.photos.before.length > 0 || data.photos.signoff.length > 0 || data.photos.after.length > 0) {
                try {
                    let currentPage = pdfDoc.addPage([612, 792]); // Letter size
                    let y = 750;

                    const addPhotoToPage = async (photoData, title) => {
                        if (y < 100) {
                            currentPage = pdfDoc.addPage([612, 792]);
                            y = 750;
                        }

                        currentPage.drawText(title, { x: 50, y, size: 14 });
                        y -= 20;

                        try {
                            const imgBytes = await fetch(photoData).then(r => r.arrayBuffer());
                            let img;

                            // Determine image type
                            if (photoData.includes('data:image/png')) {
                                img = await pdfDoc.embedPng(imgBytes);
                            } else if (photoData.includes('data:image/jpeg') || photoData.includes('data:image/jpg')) {
                                img = await pdfDoc.embedJpg(imgBytes);
                            } else {
                                // Try PNG first, then JPG
                                try {
                                    img = await pdfDoc.embedPng(imgBytes);
                                } catch {
                                    img = await pdfDoc.embedJpg(imgBytes);
                                }
                            }

                            const scale = Math.min(400 / img.width, 300 / img.height);
                            const width = img.width * scale;
                            const height = img.height * scale;

                            currentPage.drawImage(img, { x: 50, y: y - height, width, height });
                            y -= height + 30;
                        } catch (e) {
                            console.error('Error adding photo:', title, e);
                            currentPage.drawText(`[Error loading ${title}]`, { x: 50, y, size: 10 });
                            y -= 30;
                        }
                    };

                    // Function to add signoff sheet as full-page image with label at top
                    // Always portrait orientation (8.5x11), narrow margins, high quality
                    const addSignoffSheetPage = async (photoData, title) => {
                        try {
                            const imgBytes = await fetch(photoData).then(r => r.arrayBuffer());
                            let img;

                            // Determine image type and embed with high quality
                            if (photoData.includes('data:image/png')) {
                                img = await pdfDoc.embedPng(imgBytes);
                            } else if (photoData.includes('data:image/jpeg') || photoData.includes('data:image/jpg')) {
                                img = await pdfDoc.embedJpg(imgBytes);
                            } else {
                                try {
                                    img = await pdfDoc.embedPng(imgBytes);
                                } catch {
                                    img = await pdfDoc.embedJpg(imgBytes);
                                }
                            }

                            // Get original image dimensions
                            const imgWidth = img.width;
                            const imgHeight = img.height;

                            // Always use portrait orientation: 8.5 x 11 inches (612 x 792 points)
                            const pageWidth = 612;
                            const pageHeight = 792;

                            // Narrow margins: 0.25 inch (18 points) on sides, 0.5 inch (36 points) top for label
                            const sideMargin = 18;
                            const topMargin = 40;  // Room for title at top
                            const bottomMargin = 18;
                            const labelHeight = 20;

                            // Calculate available space for image
                            const availableWidth = pageWidth - (sideMargin * 2);
                            const availableHeight = pageHeight - topMargin - bottomMargin;

                            // Create portrait page
                            const signoffPage = pdfDoc.addPage([pageWidth, pageHeight]);

                            // Draw title label at top of page
                            signoffPage.drawText(title, {
                                x: sideMargin,
                                y: pageHeight - topMargin + 5,
                                size: 14,
                                color: PDFLib.rgb(0, 0, 0)
                            });

                            // Scale image to fit available space while maintaining aspect ratio
                            const scaleX = availableWidth / imgWidth;
                            const scaleY = availableHeight / imgHeight;
                            const scale = Math.min(scaleX, scaleY);

                            const finalWidth = imgWidth * scale;
                            const finalHeight = imgHeight * scale;

                            // Center image horizontally, position below title
                            const x = sideMargin + (availableWidth - finalWidth) / 2;
                            const y = bottomMargin + (availableHeight - finalHeight) / 2;

                            signoffPage.drawImage(img, {
                                x: x,
                                y: y,
                                width: finalWidth,
                                height: finalHeight
                            });

                            console.log(`Added signoff sheet (portrait 8.5x11): ${title}, original: ${imgWidth}x${imgHeight}, final: ${Math.round(finalWidth)}x${Math.round(finalHeight)}`);
                        } catch (e) {
                            console.error('Error adding signoff sheet:', title, e);
                            const errorPage = pdfDoc.addPage([612, 792]);
                            errorPage.drawText(`Error loading ${title}`, { x: 50, y: 400, size: 14 });
                        }
                    };

                    // Add all photos
                    console.log('Adding before photos:', data.photos.before.length);
                    for (let photo of data.photos.before) {
                        await addPhotoToPage(photo, 'Kompass Cart - Before');
                    }

                    console.log('Adding after photos:', data.photos.after.length);
                    for (let photo of data.photos.after) {
                        await addPhotoToPage(photo, 'Kompass Cart - After');
                    }

                    console.log('Adding signoff photos:', data.photos.signoff.length);
                    for (let i = 0; i < data.photos.signoff.length; i++) {
                        await addSignoffSheetPage(data.photos.signoff[i], `Sign-Off Sheet ${i + 1}`);
                    }

                    console.log('Photos added successfully');
                } catch (e) {
                    console.error('Error adding photo pages:', e);
                    console.warn('Continuing without photo pages');
                }
            }

            console.log('Flattening form...');
            form.flatten();

            console.log('Saving PDF...');
            const finalPdfBytes = await pdfDoc.save();

            console.log('Creating download...');
            // Download
            const blob = new Blob([finalPdfBytes], { type: 'application/pdf' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('PDF generated successfully!');
        }

        // Reset form
        function resetForm() {
            showConfirm(
                'Reset Form',
                'Are you sure you want to reset all fields? This will clear all data, including photos?',
                () => {
                    localStorage.removeItem('kompassEOD');
                    photos.before = [];
                    photos.signoff = [];
                    photos.after = [];
                    emailRecipients = [];
                    document.querySelectorAll('input, textarea').forEach(el => {
                        if (el.type === 'checkbox') el.checked = false;
                        else if (el.type === 'date') el.valueAsDate = new Date();
                        else el.value = '';
                    });
                    renderPhotos('before');
                    renderPhotos('signoff');
                    renderPhotos('after');
                    renderRecipientList();
                    updateSignaturePreview();
                    document.getElementById('hotlineDetails').style.display = 'none';
                    document.getElementById('tempSolutionField').style.display = 'none';
                }
            );
        }

        // Modal functions
        function showAlert(title, message) {
            const modal = document.getElementById('modal');
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').innerHTML = message;
            document.getElementById('modalCancel').style.display = 'none';
            modal.classList.add('show');
        }

        function showConfirm(title, message, callback) {
            const modal = document.getElementById('modal');
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').innerHTML = message;
            document.getElementById('modalCancel').style.display = 'inline-block';
            modal.classList.add('show');

            document.getElementById('modalConfirm').onclick = () => {
                modal.classList.remove('show');
                if (callback) callback();
            };
        }

        document.getElementById('modalCancel').addEventListener('click', () => {
            document.getElementById('modal').classList.remove('show');
        });

        document.getElementById('modalConfirm').addEventListener('click', () => {
            document.getElementById('modal').classList.remove('show');
        });

        // Email options modal functions
        function showEmailOptions(pdfFilename) {
            const modal = document.getElementById('emailOptionsModal');
            const { to, cc, subject, body } = window.pendingEmailData;

            document.getElementById('emailOptionsMessage').innerHTML =
                `<strong>Filename:</strong> ${pdfFilename}<br>` +
                `<strong>Location:</strong> Downloads folder<br><br>` +
                `<strong>To:</strong> ${to || '(not set)'}<br>` +
                `<strong>CC:</strong> ${cc}<br><br>` +
                `<em>Remember to attach the PDF from your Downloads folder!</em>`;

            // Show share button if Web Share API is available
            if (navigator.share) {
                document.getElementById('emailShare').style.display = 'block';
            }

            modal.classList.add('show');
        }

        // Open email app (mailto)
        document.getElementById('emailOpenApp').addEventListener('click', () => {
            const { to, cc, subject, body } = window.pendingEmailData;
            const mailtoUrl = `mailto:${encodeURIComponent(to)}?cc=${encodeURIComponent(cc)}&subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;

            // Try different methods to open email
            try {
                // First try window.open for better compatibility on some devices
                const emailWindow = window.open(mailtoUrl, '_blank');
                if (!emailWindow || emailWindow.closed) {
                    // Fallback to location.href
                    window.location.href = mailtoUrl;
                }
            } catch (e) {
                // Final fallback
                window.location.href = mailtoUrl;
            }
        });

        // Open in Outlook.com (web)
        document.getElementById('emailOpenOutlook').addEventListener('click', () => {
            const { to, cc, subject, body } = window.pendingEmailData;
            // Outlook.com compose URL format
            const outlookUrl = `https://outlook.live.com/mail/0/deeplink/compose?to=${encodeURIComponent(to)}&cc=${encodeURIComponent(cc)}&subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            window.open(outlookUrl, '_blank');
        });

        // Download email as .eml file
        document.getElementById('emailDownloadEml').addEventListener('click', () => {
            const { to, cc, subject, body, pdfFilename } = window.pendingEmailData;

            // Create .eml file content (RFC 2822 format)
            const emlContent = [
                `To: ${to}`,
                `Cc: ${cc}`,
                `Subject: ${subject}`,
                `X-Unsent: 1`,
                `MIME-Version: 1.0`,
                `Content-Type: text/plain; charset=utf-8`,
                ``,
                body,
                ``,
                `---`,
                `Note: Please attach "${pdfFilename}" from your Downloads folder before sending.`
            ].join('\r\n');

            // Create and download the .eml file
            const blob = new Blob([emlContent], { type: 'message/rfc822' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `KOMPASS EOD ${window.pendingEmailData.subject.replace(/[^a-zA-Z0-9 ]/g, '')}.eml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            const msg = document.getElementById('copySuccessMsg');
            msg.textContent = 'Email file downloaded!';
            msg.style.display = 'block';
            setTimeout(() => {
                msg.textContent = 'Copied to clipboard!';
                msg.style.display = 'none';
            }, 2000);
        });

        // Copy email details to clipboard
        document.getElementById('emailCopyAll').addEventListener('click', async () => {
            const { to, cc, subject, body, pdfFilename } = window.pendingEmailData;
            const emailText = `TO: ${to}
CC: ${cc}
SUBJECT: ${subject}

${body}

---
ATTACHMENT: ${pdfFilename} (in Downloads folder)`;

            try {
                await navigator.clipboard.writeText(emailText);
                const msg = document.getElementById('copySuccessMsg');
                msg.style.display = 'block';
                setTimeout(() => { msg.style.display = 'none'; }, 2000);
            } catch (e) {
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = emailText;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand('copy');
                document.body.removeChild(textarea);
                const msg = document.getElementById('copySuccessMsg');
                msg.style.display = 'block';
                setTimeout(() => { msg.style.display = 'none'; }, 2000);
            }
        });

        // Share via device (Web Share API)
        document.getElementById('emailShare').addEventListener('click', async () => {
            const { to, cc, subject, body, pdfFilename } = window.pendingEmailData;
            const shareText = `TO: ${to}
CC: ${cc}

${body}

---
Attach PDF: ${pdfFilename}`;

            try {
                await navigator.share({
                    title: subject,
                    text: shareText
                });
            } catch (e) {
                if (e.name !== 'AbortError') {
                    showAlert('Share Error', 'Unable to share. Try copying the email details instead.');
                }
            }
        });

        // Close email options modal
        document.getElementById('emailOptionsClose').addEventListener('click', () => {
            document.getElementById('emailOptionsModal').classList.remove('show');
        });

        // Quick view (Easter egg) - shows current form data
        async function openQuickView() {
            const data = await collectData();
            const beforeDone = data.photos.before.length > 0 || data.BeforeComplete;
            const signoffDone = data.photos.signoff.length > 0 || data.SignoffComplete;
            const afterDone = data.photos.after.length > 0 || data.AfterComplete;
            const hasSig = data.signatureDataURL ? 'Yes' : 'No';

            const content = `
                <div class="quick-view-content">
                    <div class="qv-row"><span class="qv-label">Store #</span><span class="qv-value">${data.StoreNumber || '-'}</span></div>
                    <div class="qv-row"><span class="qv-label">Date</span><span class="qv-value">${data.DateMMDDYYYY || '-'}</span></div>
                    <div class="qv-row"><span class="qv-label">Lead</span><span class="qv-value">${data.LeadName || '-'}</span></div>

                    <div class="qv-section">
                        <div class="qv-section-title">Photos</div>
                        <div class="qv-row"><span class="qv-label">Before</span><span class="qv-value">${beforeDone ? 'Done' : 'Missing'} (${data.photos.before.length})</span></div>
                        <div class="qv-row"><span class="qv-label">After</span><span class="qv-value">${afterDone ? 'Done' : 'Missing'} (${data.photos.after.length})</span></div>
                        <div class="qv-row"><span class="qv-label">Sign-off</span><span class="qv-value">${signoffDone ? 'Done' : 'Missing'} (${data.photos.signoff.length})</span></div>
                    </div>

                    <div class="qv-section">
                        <div class="qv-section-title">EOD Details</div>
                        <div class="qv-row"><span class="qv-label">Check-in</span><span class="qv-value">${data.CheckInManager || '-'}</span></div>
                        <div class="qv-row"><span class="qv-label">Check-out</span><span class="qv-value">${data.CheckOutManager || '-'}</span></div>
                        <div class="qv-row"><span class="qv-label">Hotline</span><span class="qv-value">${pickYN(data.CalledHotline)}</span></div>
                        <div class="qv-row"><span class="qv-label">PROD</span><span class="qv-value">${pickYN(data.SignedOutPROD)}</span></div>
                        <div class="qv-row"><span class="qv-label">SI</span><span class="qv-value">${pickYN(data.SignedOutSI)}</span></div>
                        <div class="qv-row"><span class="qv-label">Signature</span><span class="qv-value">${hasSig}</span></div>
                    </div>
                </div>
            `;

            showAlert('Current Status', content);
        }

        // Test setup function
        async function testSetup() {
            const loading = document.getElementById('loadingOverlay');
            loading.classList.add('show');

            let results = [];

            // Test 1: Check if PDFLib is loaded
            results.push('1. PDF Library: ' + (typeof PDFLib !== 'undefined' ? 'Loaded' : 'Not loaded'));

            // Test 2: Try to load PDF template
            const pdfPaths = [
                'End Of Day Cover Sheet Form Editable Template (1).pdf',
                './End_Of_Day_Cover_Sheet_Form_Editable_Template_(1).pdf',
                'End%20Of%20Day%20Cover%20Sheet%20Form%20Editable%20Template%20(1).pdf'
            ];

            let pdfFound = false;
            for (let path of pdfPaths) {
                try {
                    const response = await fetch(path);
                    if (response.ok) {
                        results.push(`2. PDF Template: Found at "${path}"`);
                        pdfFound = true;
                        break;
                    }
                } catch (e) {
                    // Continue trying
                }
            }

            if (!pdfFound) {
                results.push('2. PDF Template: Not found. Please ensure "End Of Day Cover Sheet Form Editable Template (1).pdf" is in the same directory as this HTML file.');
            }

            // Test 3: Check logo
            try {
                const logoResponse = await fetch('rologo.png');
                results.push('3. Logo Image: ' + (logoResponse.ok ? 'Found' : 'Not found'));
            } catch (e) {
                results.push('3. Logo Image: Error loading');
            }

            // Test 4: Check localStorage
            results.push('4. LocalStorage: ' + (typeof localStorage !== 'undefined' ? 'Available' : 'Not available'));

            // Test 5: Check saved data
            const saved = localStorage.getItem('kompassEOD');
            results.push('5. Saved Data: ' + (saved ? `Found (${(saved.length / 1024).toFixed(1)} KB)` : 'None'));

            // Test 6: Check photos
            const photoCount = photos.before.length + photos.signoff.length + photos.after.length;
            results.push(`6. Photos: ${photoCount} total (Before: ${photos.before.length}, Signoff: ${photos.signoff.length}, After: ${photos.after.length})`);

            // Test 7: Check signature
            const sigData = await getSignatureDataURL();
            results.push('7. Signature: ' + (sigData ? 'Present' : 'Not signed'));

            loading.classList.remove('show');

            showAlert('Setup Test Results', results.join('<br>'));
        }

        // Initialize on load
        window.addEventListener('load', () => {
            loadSaved();
            updateSignaturePreview();

            // Log startup info
            console.log('Kompass EOD Advanced loaded');
            console.log('PDFLib available:', typeof PDFLib !== 'undefined');
            console.log('Current URL:', window.location.href);
        });
    </script>
</body>
</html>
